function results = solve_ocp(M, problem, problem_switch, M_previous, res_previous)
    opti = casadi.Opti();
    Nb_inter = length(M.t)-1;
    
    % create collocation variables
    X = {};
    for i = 1:Nb_inter
        X{i} = opti.variable(problem.nx, M.Nk(i));
    end
    X{Nb_inter+1} = opti.variable(problem.nx, 1);
    
    U = {};
    for i = 1:Nb_inter
        if M.Nu(i) == 0 || M.Nu(i) == 1
            U{i} = opti.variable(problem.nu, 1);
        else
            U{i} = opti.variable(problem.nu, M.Nk(i));
        end
    end
    if M.Nu(end) ~= 0
        U{end+1} = opti.variable(problem.nu,1);
    end
    
    opti = add_initial_final_constraints(opti, problem, M, X, U);
    opti = add_path_constraints(opti, problem, M, X, U);
    opti = add_coll_constraints(opti, problem, M, X, U);
    opti = add_objective(opti, problem, problem_switch, M, X, U, tf);
    
    if isempty(res_previous.X{1})
        opti = add_initial_initial_guess(opti, Nb_inter, M, X, U, problem, problem_switch, tf);
    else
        opti = add_initial_guess(opti, res_previous, M_previous, M, X, U, fixed_time, tf);
    end
    
    % solve OCP   
    opti.solver('ipopt', struct('expand', true));
    %opti.solver('ipopt', struct('expand', true), struct('tol', 1.0e-15));
    opti.callback(@(i) displayTrajectoryX_intermediate(i, M, opti, X, U, problem));
    sol = opti.solve();
    
    results = construct_result(sol, X, U, M, fixed_time, tf);
end

function opti = add_initial_final_constraints(opti, problem, problem_switch, M, X, U)
    switch problem_switch
        case {0, 1, 2}
            opti.subject_to(X{1}(:,1) == problem.x0);
            opti.subject_to(X{end}(1) == problem.xf(1));
        otherwise
            opti.subject_to(X{1}(:,1) == problem.x0);
            opti.subject_to(X{end}(:,1) == problem.xf);
    end
end
function opti = add_path_constraints(opti, problem, problem_switch, M, X, U, tf)
    switch problem_switch
        case 13
            max_accel = 20; min_accel = -5;
            u = [U{:}];
            %opti.subject_to(min_accel.*(1.1.*cos(u(2,:)).^4)<=u(1,:));
            %opti.subject_to(u(1,:)<= max_accel.*(1.1.*cos(u(2,:))).^4);
            opti.subject_to(min_accel <= u(1,:) <= max_accel);
            opti.subject_to(-pi/4 <= u(2,:)); opti.subject_to(u(2,:)<= pi/4);
            
            x = [X{:}]; x1 = x(1,:); x2 = x(2,:); x3 = x(3,:);
            opti.subject_to(-pi/2 < x2 < pi/2);
            opti.subject_to(0 < x3);
            max_v = 75;
            for i = 1:length(X)-1
                opti.subject_to(X{i}(3,:) <= max_v);%.*cos((2.0.*U{i}(2,:))).^100);
            end
            
            opti.subject_to(x1 <= problem.b); opti.subject_to(x1 >= -problem.b);
        case {14, 15}
            u = [U{:}];            
            opti.subject_to(-pi/4 <= u(1,:));
            opti.subject_to(u(1,:)<= pi/4);
            
            x = [X{:}]; x1 = x(1,:); x2 = x(2,:);
            opti.subject_to(-pi/2 < x2 < pi/2);
            opti.subject_to(x1 <= problem.b); opti.subject_to(x1 >= -problem.b);
    end
end
function opti = add_coll_constraints(opti, problem, M, X, U)
    s = casadi.MX.sym('s');
    for i = 1:length(X)-1
        % collocation
        Xcoll = casadi.MX.sym('Xcoll', nx, M.Nk(i)+1);
        tau = M.sc{i};
        polEval  = casadi.Function('polEval', {Xcoll, s}, {LagrangePolynomialEval(problem.scale.*tau+problem.scale, Xcoll, s)});
        dot_Pi = casadi.Function('dot_Pi', {Xcoll, s}, {jacobian(polEval(Xcoll, s), s)},{'X', 's'},{'dPi'});
        
        if M.Nu(i) == 0         % piecewise constant control input
            uvalues = U{i}.*ones(size(U{i},1), length(tau));
        elseif M.Nu(i) == 1     % piecewise linear control input
            uvalues = U{i} + [(tau-tau(1)).*(U{i+1}(1,1)-U{i}(1,1))./(tau(end)-tau(1));(tau-tau(1)).*(U{i+1}(2,1)-U{i}(2,1))./(tau(end)-tau(1))];
        else                    % continuous control input
            uvalues = U{i};
        end
        for j = 1:M.Nk(i)
            opti.subject_to(dot_Pi([X{i}, X{i+1}(:,1)], problem.scale.*tau(j)+problem.scale) == problem.rhs(X{i}(:,j), uvalues(:,j), problem.scale.*tau(j)+problem.scale);
        end
    end
end
function opti = add_objective(opti, problem, problem_switch, M, X, U, tf)
    switch problem.problem_switch
        case {0, 1, 2}
        int_approx = 0;
        scale = problem.myTrack.total_length()/2;
        for i = 1:length(M.t)-1
            for j = 1:length(M.tc{i})-2
                a = 1/get_s_derivative(problem.myTrack, X{i}(:,j), scale*M.tc{i}(j)+scale);
                b = 1/get_s_derivative(problem.myTrack, X{i}(:,j+1), scale*M.tc{i}(j+1)+scale);
                width = scale*(M.tc{i}(j+1)-M.tc{i}(j));
                int_approx = int_approx + (a+b)/2*width;
                %int_approx = int_approx + 1/get_s_derivative(problem.myTrack, X{i}(:,j), scale*M.tc{i}(j)+scale)*(scale*(M.tc{i}(j+1)-M.tc{i}(j)));
            end
            a = 1/get_s_derivative(problem.myTrack, X{i}(:,end), scale*M.tc{i}(end-1)+scale);
            b = 1/get_s_derivative(problem.myTrack, X{i+1}(:,1), scale*M.tc{i}(end)+scale);
            width = scale*(M.tc{i}(end)-M.tc{i}(end-1));
            int_approx = int_approx + (a+b)/2*width;
        end
        opti.minimize(int_approx);
    else
        opti.minimize(tf);
    end
end
function opti = add_initial_initial_guess(opti, Nb_inter, M, X, U, problem, problem_switch, tf)
    if problem_switch == 12
        x = [X{:}];
        L1 = problem.L1; L2 = problem.L2; L3 = problem.L3; L4 = problem.L4;
        
        opti.set_initial(x(1,1:floor(end/3)),                   linspace(0, problem.L1, length(x(1,1:floor(end/3)))));
        opti.set_initial(x(1,floor(end/3)+1:floor(end/2)),      L1+(L2-L1)/2.*sin(linspace(0, pi/2, length(x(1,floor(end/3)+1:floor(end/2))))));
        opti.set_initial(x(1,floor(end/2)+1:floor(3*end/4)),    L3 - (L3-L1-(L2-L1)/2).*cos(linspace(0, pi/2, length(x(1,floor(end/2)+1:floor(3*end/4))))));
        opti.set_initial(x(1,floor(3*end/4)+1:end),               linspace(L3, L4, length(x(1, floor(3*end/4)+1:end))));
        
        opti.set_initial(x(2,1:floor(end/3)),                   0);
        opti.set_initial(x(2,floor(end/3)+1:floor(end/2)),      (L2-L1)/2-(L2-L1)/2.*cos(linspace(0, pi/2, length(x(2,floor(end/3)+1:floor(end/2))))));
        opti.set_initial(x(2,floor(end/2)+1:floor(3*end/4)),    (L2-L1)/2+(L3-L1-(L2-L1)/2).*sin(linspace(0, pi/2, length(x(2,floor(end/2)+1:floor(3*end/4))))));
        opti.set_initial(x(2,floor(3*end/4)+1:end),               (L2-L1)+(L3-L2));
        
        opti.set_initial(x(3,:), 1);
        opti.set_initial(x(4,floor(end/2)-5:floor(end/2)+5), pi/2);
        
        opti.set_initial(U(1,1:floor(end/5)), 1);
        opti.set_initial(U(1,floor(end/5)+1:end), 0);
        opti.set_initial(U(2,floor(end/3)+1:floor(end/2)), -pi/3);
        opti.set_initial(U(2, floor(end/2)+1:floor(3*end/4)), pi/4);
        
        opti.set_initial(tf, 240);
    end
    if problem_switch == 13
        x = [X{:}];
        opti.set_initial(x(1,:), 0);
        opti.set_initial(x(2,:), 0);
        opti.set_initial(x(3,:), 0.01);
        
        for k = 1:length(M.t)-1
            opti.set_initial(U{k}(1,:), 0);
            for j = 1:size(U{k},2)
                tcurr = M.tc{k}(j);
                len = problem.myTrack.total_length;
                tcurr = len/2*tcurr + len/2;
                opti.set_initial(U{k}(2,j), atan(1/problem.myTrack.evaluate_radius_curvature(tcurr)));
            end
        end
    end
    if problem_switch == 14
        x = [X{:}];
        opti.set_initial(x(1,:), 0);
        opti.set_initial(x(2,:), 0);
        
        for k = 1:length(M.t)-1
            for j = 1:size(U{k},2)
                tcurr = M.tc{k}(j);
                len = problem.myTrack.total_length;
                tcurr = len/2*tcurr + len/2;
                opti.set_initial(U{k}(1,j), atan(1/problem.myTrack.evaluate_radius_curvature(tcurr)));
            end
        end
    end
    if problem_switch == 15
        x = [X{:}];
        opti.set_initial(x(1,:), 0);
        opti.set_initial(x(2,:), 0);
        opti.set_initial(x(3,:), 0.01);
        
        for k = 1:length(M.t)-1
            for j = 1:size(U{k},2)
                tcurr = M.tc{k}(j);
                len = problem.myTrack.total_length;
                tcurr = len/2*tcurr + len/2;
                opti.set_initial(U{k}(1,j), atan(1/problem.myTrack.evaluate_radius_curvature(tcurr)));
            end
        end
    end 
end
function opti = add_initial_guess(opti, res_previous, M_previous, M, X, U, fixed_time, tf)
    if ~isempty(res_previous.X{1})
        Xinit = new_mesh_evaluateX(res_previous.X, M_previous, M);
        %plot([Xinit{:}]'); hold on;
        %plot([res_previous.X{:}]', 'color', [0.6, 0.6, 0.6]);
        for i = 1:length(Xinit)
            opti.set_initial(X{i}(1:2,:), Xinit{i}(1:2,:));
            X3 = Xinit{i}(3,:);
            X3(X3==0) = 1.0e-5;
            opti.set_initial(X{i}(3,:), X3);
        end
        
        Uinit = new_mesh_evaluateU(res_previous.U, M_previous, M);
        for i = 1:length(Uinit)-1
            opti.set_initial(U{i}, Uinit{i});
            %opti.set_initial(U(:,i), Uinit{i});
        end
        
        %{
        u = [res_previous.U{:}];
        u = u(:,1:end-1);
        global split_idx;
        for i = 1:length(split_idx)
            u = [u(:,1:i), u(:,i), u(:,i+1:end)];
        end
        opti.set_initial(U, u);
        %}
        
        if ~fixed_time
            opti.set_initial(tf, res_previous.tf);
        end
    elseif ~fixed_time
        opti.set_initial(tf, 4.5);
    end
end